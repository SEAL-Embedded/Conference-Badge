The basic info should be stored, 
let every value have number assignment, like, say:
degree = 1 // if undergrad, 2 if masters, and 3 if phd

badge must be able to read the stored info, consider the following:
1. ble.gatts_read(value_handle)
2. ble.gattc_read(conn_handle, value_handle)

//maybe store the match value somewhere and change it like how we have the SEAL rank 
and then process the match (return the response):
1. ble.gattc_write(conn_handle, value_handle, data, mode=0)

to set the values:
1. ble.gatts_write(value_handle, data, send_update=False)	

conection:
1. ble.gap_advertise(interval_us, adv_data=None, *, resp_data=None, connectable=True)

badges must be able to scan for other badges and their info, for that:
// tis below will get this event data (addr_type, addr, adv_type, rssi, adv_data)
1. ble.gap_scan(duration_ms, interval_us=1280000, window_us=11250, active=False) 


The default size of write is 20. If u remote to write more than 20 bytes. Just write to local char.
Example when using aioble module:
char.write(bytes( 64))
this should increase that char to received upto 64 bytes.

In the latest version of aioble you can also use BufferedCharacteristic(..., max_len=N) in place of Characteristic(...) when registering. i.e. if your code previously had
temp_char = aioble.Characteristic(temp_service, _ENV_SENSE_TEMP_UUID, read=True, notify=True)
you can now do
temp_char = aioble.BufferedCharacteristic(temp_service, _ENV_SENSE_TEMP_UUID, read=True, notify=True, max_len=50)

add something like this later:
# Badge with multiple fields
alice_info = [1, 1, 3, 5, 8, 2]  # [major, degree, year, interest1, interest2, hobby]
badge = Badge(alice_info, name="Alice's Badge")

# Easy to add more fields later:
extended_info = [1, 1, 3, 5, 8, 2, 10, 15]  # Added 2 more fields